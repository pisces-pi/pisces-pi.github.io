<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UI引导线</title>
    <link href="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/"/>
    <url>/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<ul><li>UI引导线是存在于屏幕空间的、由指定的起点指向终点的线段</li><li>其中构成的线段的图案可自由配置</li></ul><hr><h1 id="材质">材质</h1><h2 id="图案">图案</h2><ul><li>使用一张边缘亮度高于中间的箭头图案：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/GuideLinePattern.png" width="30%"></li><li>图案设置为Clamp的寻址方式；且不使用Mipmap</li><li>采样结果：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/PatternSample.png" width="30%"></li></ul><h2 id="旋转">旋转</h2><ul><li>定义<strong>StartPoX</strong>、<strong>StartPosY</strong>和<strong>RotateAngle</strong>三个参数。其中前两者为引导线在屏幕上的标准化坐标；后者是为使引导线由起点指向终点所需旋转的角度</li><li>使用旋转矩阵对UV进行旋转，旋转中心即为<code>float2(StartPoX, StartPosY)</code>，旋转角度为<code>RotateAngle</code></li><li>得到结果(绕(0.7, 0.7)旋转45°为例)：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/Rotate.png" width="30%"></li></ul><h2 id="u方向范围计算">U方向范围计算</h2><ul><li>旋转之后，U方向的分布为：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/RotateU.png" width="30%"></li><li>通常来说，引导线不应该占据整个屏幕空间，且应允许配置其宽度</li><li>定义一个参数<strong>Width</strong>表示线段的宽度</li><li>计算U方向的范围遮罩： <figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">float</span> halfWidth = Width / <span class="hljs-number">2</span>;  //宽度的一半<br><span class="hljs-type">float</span> range<span class="hljs-keyword">Start</span> = max(StartPosX - halfWidth, <span class="hljs-number">0.0</span>);  //范围起点<br><span class="hljs-type">float</span> range<span class="hljs-keyword">End</span> = max(StartPosX + halfWidth, <span class="hljs-number">0.0</span>);  //范围终点<br><span class="hljs-type">float</span> startMask = saturate(floor(UV.x / range<span class="hljs-keyword">Start</span>));  //起点遮罩<br><span class="hljs-type">float</span> endMask = saturate(floor(UV.x / range<span class="hljs-keyword">End</span>));  //终点遮罩<br><span class="hljs-keyword">return</span> startMask - endMask;<br></code></pre></div></td></tr></table></figure> 起点遮罩减去终点遮罩：</li></ul><center><img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/StartMask.png" width="20%"> - <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/EndMask.png" width="20%"> = <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/URange.png" width="20%"></center><ul><li><p>再计算渐变区域： 先令<code>UV.x -= rangeStart(上方代码块中的临时变量)</code>，使0-1值域位于所需范围：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/GradientRange.png" width="30%"></p><p>再令<code>UV.x = frac(UV.x / Width)</code>，得到周期性的0-1范围：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/UFracResult.png" width="30%"></p><p>最后将遮罩和渐变区域相乘得到所需的U方向范围：</p></li></ul><center><img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/URange.png" width="20%"> * <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/UFracResult.png" width="20%"> = <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/UGradientRange.png" width="20%"></center><h2 id="v方向范围计算">V方向范围计算</h2><ul><li>旋转之后，V方向的分布为：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/RotateV.png" width="30%"></li><li>设引导线的长度为<strong>TotalDistance</strong>；我们期望图案在终点处保持完整，而在起点处可以被截断，故首先在V方向上偏移，使V向上的0值位于终点处：<code>UV.y = max(UV.y + (TotalDistance - StartPosY), 0)</code>：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VOffset.png" width="30%"></li><li>之后根据宽度进行frac操作以实现Tilling：<code>frac(UV.y / Width)</code>：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VFracResult.png" width="30%"></li><li>另计算用于截断的遮罩：<code>saturate(floor((1.0 - UV.y) / max((1.0 - StartPosY), 0)))</code>：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VMask.png" width="30%"></li><li>最后将遮罩和之前的Tilling后的值相乘以得到所需的V向范围：</li></ul><center><img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VFracResult.png" width="20%"> * <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VMask.png" width="20%"> = <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VRange.png" width="20%"></center><h2 id="构造uv">构造UV</h2><ul><li>首先确定好V方向的值，为：</li></ul><center><img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VRange.png" width="20%"> * <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/URange.png" width="20%"> = <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/ResultV.png" width="20%"></center><ul><li>之后根据得到的V向的值，对其使用<code>ceil</code>操作上取整得到一个遮罩，再去乘上原来的U向的值：</li></ul><center><img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/UGradientRange.png" width="20%"> * <span class="math inline">\(\Biggl(\)</span> <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/ResultV.png" width="20%"> <span class="math inline">\(\xrightarrow{ceil}\)</span> <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/VCeil.png" width="20%"> <span class="math inline">\(\Biggr)\)</span> <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/ResultU.png" width="20%"></center><ul><li>最后构造出所需的UV：</li></ul><center>append <span class="math inline">\(\Biggl(\)</span> <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/ResultU.png" width="20%"> , <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/ResultV.png" width="20%"> <span class="math inline">\(\Biggr)\)</span> = <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/ResultUV.png" width="20%"></center><ul><li>此时采样乘上一个颜色的结果：</li></ul><p><img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/InitSample.png" width="30%"></p><h2 id="弯曲">弯曲</h2><h3 id="获取v向的0-1范围">获取V向的0-1范围</h3><ul><li>使引导线弯曲以添加更加丰富的效果，这里使用一个抛物线来实现</li><li>首先需要得到一个灰度范围，由终点处的0值线性插值到起点处的1值</li><li>以旋转后的UV的V向作为计算输入，令<code>UV.y = max(UV.y + (TotalDistance - StartPosY), 0.0)</code>，使得0值位于线段的终点处；此时V向的值域为<span class="math inline">\([0, 1 + (TotalDistance - StartPosY)]\)</span></li><li>再令<code>UV.y /= 1 + (TotalDistance - StartPosY)</code>，使V向的值位于0-1之间</li><li>最后令<code>UV.y = min(UV.y / StartPosY, 1.0)</code>，使得线段起点的V向值为1</li><li>得到：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/InitBend.png" width="30%"></li></ul><h3 id="利用抛物线实现弯曲">利用抛物线实现弯曲</h3><ul><li>由于我们需要的是线段中心的弯曲程度最大，所以需要一个以x = 0.5对称的抛物线，且在横坐标0和1处的值为0</li><li>易得公式为：<span class="math inline">\(f(x) = bend * x * (1 - x)\)</span>，其中<span class="math inline">\(Bend\)</span>为弯曲程度，可定义为<strong>BendLevel</strong></li><li>对之前得到的结果进行操作：<code>Bend = BendLevel * UV.y * (1.0 - UV.y)</code></li><li>最后，使旋转过的<code>UV.x += Bend</code>，再按上文所述构造UV，得到：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/BendUV.png" width="30%"></li><li>进行图案采样的结果：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/BendUVSample.png" width="30%"></li></ul><h2 id="半透明">半透明</h2><ul><li>引导线可添加由起点到终点的完全透明到不透明的渐变过渡效果</li><li>令<code>pow(1 - UV.y, OpacityRange)</code>，其中的UV.y为上文中最终得到的<strong>V向值域为0-1间的值</strong>以得到一个渐变区域；其中<strong>OpacityRange</strong>用于控制半透明的范围：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/OpacityRange.png" width="30%"></li><li>采样结果：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/OpacitySample.png" width="30%"></li></ul><h2 id="动效">动效</h2><h3 id="缓出移动">缓出移动</h3><ul><li>引导线的第一个动效为由起点移至终点的缓出效果</li><li>这里使用一个简单的缓出公式：<span class="math inline">\(f(x) = 2x - x^2\)</span>，其中x为<span class="math inline">\(0\rightarrow1\)</span>的变量，可先通过<code>frac(Time)</code>传入，即 <figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">float</span> fracTime = frac(Time);<br><span class="hljs-attribute">float</span> offsetTime = <span class="hljs-number">2</span> * fracTime - pow(fracTime, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure></li><li>在之前计算V方向范围时，我们利用<code>UV.y = max(UV.y + (TotalDistance - StartPosY), 0)</code>使UV在V向上平移；这里我们先令<code>TotalDistance *= offsetTime</code>，使<code>TotalDistance</code>由0变化为最终值，以实现缓出的移动效果：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/EaseOut.gif" width="30%"></li><li>最终采样结果： <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/EaseOutResult.gif" width="30%"></li></ul><h3 id="消隐">消隐</h3><ul><li>引导线的第二个动效是令引导线逐渐消失</li><li>实现只需在之前的半透明区域基础上乘上一个随时间由<span class="math inline">\(1\rightarrow0\)</span>的值(<code>1 - frac(Time)</code>)即可：</li></ul><center><img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/OpacityFade.gif" width="20%"> * <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/OpacityRange.png" width="20%"> = <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/OpacityRangeFade.gif" width="20%"></center><ul><li>最终效果： <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/OpacityFadeResult.gif" width="30%"></li></ul><h3 id="动效结合">动效结合</h3><ul><li>需要将上述的两个动效结合起来，先进行缓出，再进行消隐</li><li>设两个变量<strong>OffsetSpeed</strong>和<strong>FadeSpeed</strong>，分别表示缓出的速度和消隐的速度</li><li>进行计算： <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">float</span> offsetTime = <span class="hljs-number">1.0</span> / OffsetSpeed;<br><span class="hljs-built_in">float</span> fadeTime = <span class="hljs-number">1.0</span> / FadeSpeed;<br><span class="hljs-built_in">float</span> totalTime = offsetTime + fadeTime;<br><span class="hljs-built_in">float</span> totalSpeed = <span class="hljs-number">1.0</span> / totalTime;<br><br><span class="hljs-built_in">float</span> offsetRatio = offsetTime / totalTime;  <span class="hljs-comment">//偏移占总时间的比例</span><br><span class="hljs-built_in">float</span> fadeRatio = fadeTime / totalTime;  <span class="hljs-comment">//消隐占总时间的比例</span><br><br><span class="hljs-built_in">float</span> fracTime = frac(Time * TotalSpeed);  <span class="hljs-comment">//最后由时间传出的值域控制在0-1</span><br><span class="hljs-built_in">float</span> time4Offset = saturate(fracTime / offsetRatio);  <span class="hljs-comment">//时间的前部分用于进行偏移</span><br><span class="hljs-built_in">float</span> time4Fade = saturate((fracTime - offsetRatio) / fadeRatio);  <span class="hljs-comment">//时间的后部分用于消隐</span><br></code></pre></div></td></tr></table></figure></li><li>将上述计算得到的<strong>time4Offset</strong>和<strong>time4Fade</strong>分别应用在偏移和消隐上即可： <img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/DynResult.gif" width="30%"></li></ul><h2 id="屏幕适配">屏幕适配</h2><ul><li>由于UI引导线存在于屏幕空间，因此需要根据屏幕大小进行适配</li><li>以16:9的屏幕长宽比为例，此时直接采样的结果：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/PreScreenAdapt.png" width="30%"></li><li>定义一个参数Aspect，表示屏幕的长款比；首先将它作为U方向的Tilling倍数，在16:9的情况下值即为<span class="math inline">\(\frac{16}{9}\)</span></li><li>对于本例来说，只需令所有的<code>StartPosX *= Aspect</code>即可：<img src="/2022/02/06/UI%E5%BC%95%E5%AF%BC%E7%BA%BF/ScreenAdapt.png" width="30%"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>作品集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连接线</title>
    <link href="/2022/02/03/ConnectLine/"/>
    <url>/2022/02/03/ConnectLine/</url>
    
    <content type="html"><![CDATA[<ul><li>连接线可用于场景中两个点之间的指向表示</li></ul><hr><h1 id="材质">材质</h1><h2 id="透明度输入">透明度输入</h2><h3 id="中间箭头">中间箭头</h3><h4 id="采样用图">采样用图</h4><ul><li><img src="/2022/02/03/ConnectLine/Arrow.png" width="30%"></li><li>由于涉及纹理动画，贴图应保留一定的出血，且寻址方式要设为Clamp</li><li>为防止据相机较远时的采样问题，设置不使用Mipmap</li><li>采样结果：<img src="/2022/02/03/ConnectLine/InitSample.png" width="30%"></li></ul><h4 id="缩放">缩放</h4><ul><li>设钳制在[0, 1]的缩放系数<strong>ScaleLevel</strong>，令<code>UV \= ScaleLevel</code>以缩放UV并重新采样：<img src="/2022/02/03/ConnectLine/UVScale.png" width="30%"></li></ul><h4 id="v方向偏移">V方向偏移</h4><ul><li>缩放后为保证箭头仍位于V方向的中间，需进行偏移</li><li>缩放后UV在V方向的最大值为<code>VMax = 1.0 / ScaleLevel</code>，则应该将箭头向下移动<code>VMax / 2 - 0.5</code>个单位，即V方向的偏移量为<code>VOffset = -(VMax / 2 - 0.5)</code>：<img src="/2022/02/03/ConnectLine/VOffset.png" width="30%"></li></ul><h4 id="u方向偏移">U方向偏移</h4><ul><li>为表示连接线的指向性，需要使箭头在U方向进行纹理动画</li><li>缩放后UV在U方向的最大值为<code>UMax = 1.0 / ScaleLevel</code>，则U方向箭头的移动范围为<code>[-1, UMax]</code></li><li>为控制箭头的移动速度，则利用<code>NormalizedTime = frac(Time * MovSpeed)</code>做循环动画</li><li>综上，得到U方向的偏移量为<code>UOffset = NormalizedTime * -(UMax + 1) + 1</code></li><li>偏移后的结果：<img src="/2022/02/03/ConnectLine/UOffset.gif" width="30%"></li></ul><h3 id="两侧线段">两侧线段</h3><h4 id="采样用图-1">采样用图</h4><ul><li>两侧线段使用一张Ramp图即可，方便控制：<img src="/2022/02/03/ConnectLine/ArrowRamp.png" width="30%"></li><li>采样结果：<img src="/2022/02/03/ConnectLine/RampSample.png" width="30%"></li></ul><h4 id="旋转">旋转</h4><ul><li>UE中实现该效果时，习惯以X轴方向为前向，故需要将Ramp图逆时针旋转90°</li><li>这里利用二维旋转矩阵对UV进行变换，即<span class="math inline">\(\dbinom{U&#39;}{V&#39;} = \begin{bmatrix} cos\alpha &amp; -sin\alpha \\ sin\alpha &amp; cos\alpha \end{bmatrix} \dbinom{U}{V}\)</span></li><li>由于我们需要以UV中心旋转，所以需要先令<code>UV -= float2(0.5, 0.5)</code>使移动到中心处，然后对U和V分量分别进行点乘以完成上述的矩阵乘法操作，最后再令<code>UV += float2(0.5, 0.5)</code>移回原位</li><li><strong>旋转前应进行所需的缩放和平移操作</strong>，这里先展示单独旋转的结果：<img src="/2022/02/03/ConnectLine/RampRot.png" width="30%"></li></ul><h4 id="v方向缩放">V方向缩放</h4><ul><li>两侧线段由宽变窄，首先通过缩放来实现该效果</li><li>设线段末端宽度占比为<code>EndPercent</code>∈[0, 1]</li><li>得到V方向缩放量<code>VScale = UV.x * (EndPercent - 1) + 1</code>，使得缩放由1变为EndPercent</li><li>令<code>UV \= float2(1.0, VScale)</code>以缩放UV：<img src="/2022/02/03/ConnectLine/RampScale.png" width="30%"></li></ul><h4 id="v方向偏移-1">V方向偏移</h4><ul><li>对线段在V方向进行偏移以修正缩放的结果</li><li>与箭头的偏移处理相似，由于缩放的最大值为<code>VMax = 1.0 / VScale</code>，故偏移量为<code>VOffset = -(VMax / 2 - 0.5)</code></li><li>令<code>UV += float2(0, VOffset)</code>：<img src="/2022/02/03/ConnectLine/RampOffset.png" width="30%"></li></ul><h3 id="v方向透明度渐变">V方向透明度渐变</h3><h4 id="箭头和两侧线段的叠加">箭头和两侧线段的叠加</h4><ul><li>将上述箭头和线段的结算结果做加法：<img src="/2022/02/03/ConnectLine/ArrowRampAdd.gif" width="30%"></li></ul><h4 id="渐变">渐变</h4><ul><li>为防止连接线两端过于生硬，添加渐变效果；这里利用两个SmoothStep相减的方式来实现：<img src="/2022/02/03/ConnectLine/VGradient.png" width="30%"></li><li>将渐变与之前的叠加结果相乘：<img src="/2022/02/03/ConnectLine/ArrowRampAddGradient.gif" width="30%"></li></ul><h2 id="颜色输入">颜色输入</h2><ul><li>将所需要设置的颜色乘上明度控制以及饱和度控制，作为自发光颜色即可</li><li>结合之前的透明度输入得到结果：<img src="/2022/02/03/ConnectLine/ColorInput.gif" width="30%"></li></ul><h2 id="顶点偏移输入">顶点偏移输入</h2><ul><li>连接线应为起点和终点之间的一条曲线，这里使用抛物线来表示</li><li>这里应用的抛物线公式为<span class="math inline">\(f(x) = \frac{(x-a)^2-a^2}{-2b}\)</span>，其中a应设置为起终点距离的一半；b控制抛物线的弯曲程度</li><li>由于连接线后续通过缩放进行延长，因此这里的a为初始Mesh的尺寸的一半，如可设为50个单位长度</li><li>b可设置为<code>1.0 / BendLevel</code>，<strong>BendLevel</strong>可设为弯曲度的调整参数</li><li>x可设置为每个顶点的局部坐标；最后得到的f(x)作为z分量应用在顶点偏移即可</li><li>调整<strong>BendLevel</strong>的结果：<img src="/2022/02/03/ConnectLine/BendLevel.gif" width="50%"></li></ul><hr><h1 id="模型">模型</h1><ul><li>基础模型使用一张UE中100*100单位大小的平面即可，但由于需要弯曲，因此需要在X方向上进行细分；令由于需配合材质中顶点输入的抛物线计算，将模型的轴心设为一侧的中点</li><li><img src="/2022/02/03/ConnectLine/ArrowPlane.png" width="30%"></li></ul><hr><h1 id="蓝图">蓝图</h1><ul><li><img src="/2022/02/03/ConnectLine/BP.png" width="100%"></li><li>其中ArrowHeight为模型的宽度，一般设为100个单位；Aspect为连接线的长宽比</li></ul><hr><h1 id="最终效果">最终效果</h1><p><img src="/2022/02/03/ConnectLine/Result.gif" width="100%"></p>]]></content>
    
    
    
    <tags>
      
      <tag>作品集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Niagara学习</title>
    <link href="/2022/01/23/Niagara%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/01/23/Niagara%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="niagara学习">Niagara学习</h1><h2 id="层级关系">层级关系</h2><ul><li>系统-&gt;发射器-&gt;粒子</li><li>组-&gt;模块 ## 系统 ### 组</li><li>System Settings 设置</li><li>System Spawn 生成</li><li>System Update 更新 ## 发射器</li><li>发射器以堆栈运行，即从上到下运行每个组的内容</li><li>左上角复选框：该发射器是否参与运算</li><li>小人图标：孤立当前发射器，其他发射器隐藏</li><li>小人右侧图标：显示了目前的渲染器(renderer)</li><li>节点上右键可以控制选中节点的启用和孤立设置 ### 组</li><li>Emitter Settings 设置</li><li>Emitter Spawn 发射器生成</li><li>Emitter Update 发射器更新</li><li>Particle Spawn 粒子生成</li><li>Particle Update 粒子更新</li><li>Add Event Handler 添加事件</li><li>Render 渲染 ### 循环与发射状态</li><li>在Emitter Update组的Emitter State模块</li><li>Inactive Responce决定了发射器的循环 ## 继承</li><li>对于继承操作，若继承的是来自模板的发射器，则可以进行对继承下来的模块编辑；否则不可以</li><li>同理，由非模板的发射器构建的系统里也不能直接修改继承的发射器模块</li><li>被继承的发射器在父发射器的模块被修改时将同步更改自己的模块</li><li>发射器的Asset Options-&gt;Is Template Asset被勾选后，即可变为一个模板资产</li><li>对于系统中使用的模板发射器，若后续将该发射器变为非模板，它仍可在系统中被修改模块；除非发射器被重新创建 ## TimeLine</li><li>TimeLine上的项可以展开，然后可通过类似打关键帧的方式添加burst的spawn模块</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学知识</title>
    <link href="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数学知识">数学知识</h1><h2 id="函数">1.函数</h2><ul><li><h3 id="缓动函数">缓动函数</h3><ol type="1"><li>缓入/缓出函数的切换：<ul><li>设缓入函数为<span class="math inline">\(f(x)\)</span>，缓出函数为<span class="math inline">\(g(x)\)</span>，则<span class="math inline">\(g(x)=1-f(1-x)\)</span></li></ul></li><li>缓入缓出函数的构造(定义域在<span class="math inline">\([0,1]\)</span>)：<ul><li>设原始的缓入函数和缓出函数为<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(g(x)\)</span></li><li>设变换后的缓入函数和缓出函数为<span class="math inline">\(F(x)\)</span>和<span class="math inline">\(G(x)\)</span></li><li>则可构造缓入缓出函数：<span class="math inline">\(\begin{cases}F(x)=\frac{f(2x)}{2}, x\in{[0, 0.5]} \\ G(x)=\frac{g(2(x-0.5))}{2}+0.5, x\in{[0.5, 1]}\end{cases}\)</span>；可对x做<span class="math inline">\(round(x)\)</span>操作后，以其为alpha进行线性插值，避免产生分段</li></ul></li><li>几种缓动函数<ul><li>SmoothStep:<ul><li>图像：<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/SmoothStep.png" width="30%"></li><li>先令<span class="math inline">\(f(x)=saturate(\frac{x-t_1}{t_2-t_1})\)</span>；<span class="math inline">\(t_1\)</span>和<span class="math inline">\(t_2\)</span>是函数值为0与1处的横坐标值</li><li>则SmoothStep为<span class="math inline">\(F(x)=f(x)^2*(3-2f(x))\)</span></li><li>当使两个SmoothStep相减时，可得到缓入缓出分布在两端的结果：<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/SmoothStepMinus.png" width="30%"></li></ul></li><li>最简单的EaseIn/EaseOut:<ul><li><span class="math inline">\(f(x)=x^2\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/x^2.png" width="30%"></li><li><span class="math inline">\(g(x)=2x-x^2\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/2x-x^2.png" width="30%"></li></ul></li><li>较缓的EaseIn/EaseOut:<ul><li><span class="math inline">\(f(x)=1-sin(\frac{\pi}{2}(1-x))\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/1-sin(frac{pi}{2}(1-x)).png" width="30%"></li><li><span class="math inline">\(g(x)=sin(\frac{\pi}{2}x)\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/sin(frac{pi}{2}x).png" width="30%"></li></ul></li><li>迅速的EaseIn/EaseOut:<ul><li><span class="math inline">\(f(x)=1-\sqrt{1-x^2}\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/1-sqrt{1-x^2}.png" width="30%"></li><li><span class="math inline">\(g(x)=\sqrt{2x-x^2}\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/sqrt{2x-x^{2}}.png" width="30%"></li></ul></li><li>BackEaseIn/EaseOut：端点略有收回<ul><li><span class="math inline">\(f(x)=1-g(1-x)\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/1-f(1-x).png" width="30%"></li><li><span class="math inline">\(g(x)=x^b+kxsin(\pi{}x)\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/x^{b}-kxsin(pi x).png" width="30%"></li></ul></li></ul></li></ol></li><li><h3 id="周期函数">周期函数</h3><ol type="1"><li>扫描线型非连续周期函数<ul><li><span class="math inline">\(f(x)=mod(kx, b)\)</span>-&gt;<span class="math inline">\(f(x)\in{[0, b]}\)</span>；k为<span class="math inline">\(x\in{[tb, tb+b]},t\in{N}\)</span>时单次变化的重复次数<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/mod(kx, b).png" width="30%"></li></ul></li><li>线性连续周期函数<ul><li><span class="math inline">\(f(x)=abs(mod(2kx-1, 2)-1)\)</span>，k用于控制函数的频率<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/abs(mod(2kx-1, 2)-1).png" width="30%"></li></ul></li><li>非线性周期函数<ul><li><span class="math inline">\(f(x)=abs(sin(k\pi{x}))\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/abs(sin(kpi{x})).png" width="30%"></li></ul></li></ol></li><li><h3 id="实用函数">实用函数</h3><ol type="1"><li>抛物线<ul><li>函数原型：<span class="math inline">\(f(x) = \frac{(x-a)^2-a^2}{-2b}\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/frac{(x-a)^{2}-a^{2}}{-2b}.png" width="30%"></li><li>该抛物线于x轴相交于原点和<span class="math inline">\((2a,0)\)</span>点</li><li>b可用于控制抛物线的弧度</li></ul></li><li>振荡函数<ul><li><span class="math inline">\(f(x)=\frac{n^xsin(2k\pi{x}+\frac{\pi}{2})}{t}\)</span><img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/frac{n^xsin(2kpi{x}+frac{pi}{2})}{t}.png" width="30%">；n控制振荡衰减/增益的速度、k控制振荡的频率、t控制振荡的幅度</li></ul></li><li>函数离散化，可用于表示次数<ul><li>设原函数为<span class="math inline">\(f(x)\)</span>，离散化后的函数为<span class="math inline">\(g(x)\)</span>，则：<span class="math inline">\(g(x)=f(x)+mod(-f(x),a)\)</span>，a为对f(x)的在y轴上的采样周期；以sinx为例：<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/f(x)+mod(-f(x),a).png" width="30%"></li></ul></li><li>弹跳Bounce<ul><li>图像：<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/Bounce.png" width="30%"></li><li>函数原型为：<span class="math inline">\(f(x)=c^2-(ax-b)^2\)</span></li><li>设t为弹跳次数、p为衰减周期、l为衰减程度</li><li>设中间变量<span class="math inline">\(n=(1-\sqrt{1-x^p}+mod(\sqrt{1-x^p}, \frac{1}{t}))*t\)</span></li><li>则每次弹跳高度 <span class="math inline">\(c^2=(1-\frac{n-1}{t})^l\)</span></li><li>设函数与y轴交点横坐标为<span class="math inline">\(x_0\)</span>和<span class="math inline">\(x_1\)</span>，则<span class="math inline">\(x_0=\sqrt[p]{1-(1-\frac{n-1}{t})^2};x_1=\sqrt[p]{1-(1-\frac{n}{t})^2}\)</span></li><li>最后，令<span class="math inline">\(a=\frac{2c}{x_1-x_0};b=ax_0+c\)</span></li></ul></li><li>使能(Enable)函数<ul><li>图像：<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/EnableFunc.png" width="30%"></li><li>简版：<span class="math inline">\(f(x)=ceil(sin(k\pi{x}))\)</span></li><li>k为使能切换的次数的1/2</li><li>繁版：<span class="math inline">\(f(x)=min(floor(\frac{abs(mod(2kx-p, 2)-1)}{1-p}), 1)\)</span></li><li>k为使能切换的次数</li><li>p为1值在切换过程中所占比例</li></ul></li><li>阶梯函数<ul><li>图像：<img src="/2021/12/28/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/StairFunc.png" width="30%"></li><li>自增的离散函数：<span class="math inline">\(d(x)=x+mod(-x, \frac{1}{n})\)</span></li><li>平移自增函数：<span class="math inline">\(t(x)=(x-\frac{1}{n})+mod(\frac{1}{n}-x, \frac{1}{n})\)</span></li><li>自增的扫描线式函数：<span class="math inline">\(s(x)=mod(2x, \frac{2}{n})+t(x)\)</span></li><li>阶梯函数：<span class="math inline">\(f(x)=min(s(x),d(x))\)</span>，n表示0-1内的阶梯数；x可变为其他函数以实现任意函数的阶梯化</li></ul></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
